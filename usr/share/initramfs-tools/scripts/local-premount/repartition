#!/bin/sh

set -e

case "${1}" in
  prereqs)
    echo ""
    exit 0
    ;;
esac

# Check if repartition is requested
if ! grep -q repartition /proc/cmdline; then
  exit 0
fi

. /scripts/functions
. /scripts/local

# Local logging function for informational messages
log_info_msg()
{
	_log_msg "Info: %s\\n" "$*"
}

# Watchdog variables
WATCHDOG_DEV="/dev/watchdog0"
WATCHDOG_SYSFS="/sys/class/watchdog/watchdog0"
WATCHDOG_INTERVAL=10
WATCHDOG_PID=""

# Detect watchdog device and read its timeout
detect_watchdog()
{
	# Check for watchdog device
	if [ ! -c "$WATCHDOG_DEV" ]; then
		log_info_msg "No watchdog device found, continuing without watchdog petting"
		return 1
	fi
	
	
	# Check if watchdog is active
	if [ -r "$WATCHDOG_SYSFS/state" ]; then
		STATE=$(cat "$WATCHDOG_SYSFS/state" 2>/dev/null | tr '[:upper:]' '[:lower:]' | tr -d '[:space:]')
		case "$STATE" in
			inactive|0|disabled)
				log_info_msg "Watchdog device found but not active, continuing without watchdog petting"
				return 1
				;;
		esac
	fi
	
	# Read timeout from sysfs
	if [ -r "$WATCHDOG_SYSFS/timeout" ]; then
		WATCHDOG_TIMEOUT=$(cat "$WATCHDOG_SYSFS/timeout" 2>/dev/null || echo "15")
		# Calculate safe petting interval: max(5, min(timeout/2, 10))
		WATCHDOG_INTERVAL=$((WATCHDOG_TIMEOUT / 2))
		if [ "$WATCHDOG_INTERVAL" -lt 5 ]; then
			WATCHDOG_INTERVAL=5
		elif [ "$WATCHDOG_INTERVAL" -gt 10 ]; then
			WATCHDOG_INTERVAL=10
		fi
		log_info_msg "Watchdog detected: $WATCHDOG_DEV (timeout: ${WATCHDOG_TIMEOUT}s, petting interval: ${WATCHDOG_INTERVAL}s)"
	else
		log_info_msg "Watchdog device found but cannot read timeout, using default interval"
		WATCHDOG_INTERVAL=10
	fi
	return 0
}

# Start background watchdog petting process
start_watchdog_petter()
{
	if [ ! -c "$WATCHDOG_DEV" ]; then
		return 0
	fi
	
	log_info_msg "Starting watchdog petter (interval: ${WATCHDOG_INTERVAL}s)"
	(
		# Open watchdog device and keep it open
		exec 3> "$WATCHDOG_DEV" || exit 1
		
		while true; do
			echo 1 >&3 2>/dev/null || break
			sleep "$WATCHDOG_INTERVAL"
		done
		
		# Close file descriptor on exit
		exec 3>&-
	) &
	WATCHDOG_PID=$!
}

# Stop background watchdog petting process
stop_watchdog_petter()
{
	if [ -n "$WATCHDOG_PID" ]; then
		log_info_msg "Stopping watchdog petter"
		kill "$WATCHDOG_PID" 2>/dev/null || true
		wait "$WATCHDOG_PID" 2>/dev/null || true
		WATCHDOG_PID=""
	fi
}

# Trap handler to ensure watchdog petter is stopped on exit
cleanup_watchdog()
{
	stop_watchdog_petter
}

# Set trap to cleanup watchdog on script exit
trap cleanup_watchdog EXIT

# Configurable partition sizes (in GiB)
ROOTFS_SIZE_GIB=6

get_device_info()
{
	log_begin_msg "Getting device information"
	
	set +e
	local_device_setup "$ROOT" "root file system"
	set -e
	
	ROOT_PART_NAME="$(lsblk -no kname "$DEV")"
	ROOT_DEV_NAME="$(lsblk -no pkname "$DEV")"
	ROOT_DEV="/dev/$ROOT_DEV_NAME"
	ROOT_PART_NUM=$(cat "/sys/block/$ROOT_DEV_NAME/$ROOT_PART_NAME/partition")
	
	log_info_msg "Root device: $ROOT_DEV"
	log_info_msg "Root partition: $ROOT_PART_NAME (partition $ROOT_PART_NUM)"
	
	log_end_msg
}

check_mbr_and_read_layout()
{
	log_begin_msg "Checking partition table type"
	
	# Use parted to read partition table in machine-readable format (in sectors)
	PARTED_OUTPUT=$(parted -m "$ROOT_DEV" u s print 2>&1)
	if [ $? -ne 0 ]; then
		log_warning_msg "Failed to read partition table"
		return 1
	fi
	
	# Extract partition table type from second line (format: device:size:transport:logical_sector:physical_sector:partition_table_type:model:)
	# First line is "BYT;", second line has device info
	PT_TYPE=$(echo "$PARTED_OUTPUT" | sed -n '2p' | cut -d: -f6)
	log_info_msg "Partition table type: $PT_TYPE"
	
	# Check if MBR/msdos
	if [ "$PT_TYPE" != "msdos" ]; then
		log_warning_msg "Expected MBR partition table, found: $PT_TYPE. Skipping."
		return 1
	fi
	
	# Count partitions (skip header line)
	PART_COUNT=$(echo "$PARTED_OUTPUT" | tail -n +3 | grep -c "^[0-9]")
	log_info_msg "Found $PART_COUNT partitions"
	
	if [ "$PART_COUNT" -ne 2 ]; then
		log_warning_msg "Expected 2 partitions, found $PART_COUNT. Skipping."
		return 1
	fi
	
	# Extract partition info (format: number:start:end:size:filesystem:name:flags)
	PART_LINES=$(echo "$PARTED_OUTPUT" | tail -n +3)
	BOOTFS_START=$(echo "$PART_LINES" | sed -n '1p' | cut -d: -f2 | sed 's/s$//')
	BOOTFS_END=$(echo "$PART_LINES" | sed -n '1p' | cut -d: -f3 | sed 's/s$//')
	ROOTFS_START=$(echo "$PART_LINES" | sed -n '2p' | cut -d: -f2 | sed 's/s$//')
	ROOTFS_END=$(echo "$PART_LINES" | sed -n '2p' | cut -d: -f3 | sed 's/s$//')
	
	log_info_msg "Bootfs: sectors $BOOTFS_START - $BOOTFS_END"
	log_info_msg "Rootfs: sectors $ROOTFS_START - $ROOTFS_END"
	
	log_end_msg
	return 0
}

calculate_boundaries()
{
	log_begin_msg "Calculating new partition boundaries"
	
	# Get device size
	ROOT_DEV_SIZE=$(cat "/sys/block/$ROOT_DEV_NAME/size")
	# Reserve space at the end for MBR (EBR overhead is handled automatically by sfdisk)
	DEVICE_END=$((ROOT_DEV_SIZE - 1))
	
	log_info_msg "Device size: $ROOT_DEV_SIZE sectors"
	
	# Calculate size constants in sectors
	ROOTFS_SIZE_SECTORS=$((ROOTFS_SIZE_GIB * 1024 * 1024 * 1024 / 512))
	LIMIT_16GIB_SECTORS=$((16 * 1024 * 1024 * 1024 / 512))
	
	# Calculate partition boundaries
	# Partition 1 (bootfs): preserve original from MBR
	NEW_BOOTFS_START=$BOOTFS_START
	NEW_BOOTFS_END=$BOOTFS_END
	
	# Partition 2 (rootfs): keep original start, resize to ROOTFS_SIZE_GIB
	NEW_ROOTFS_START=$ROOTFS_START
	NEW_ROOTFS_END=$((NEW_ROOTFS_START + ROOTFS_SIZE_SECTORS - 1))
	
	# Partition 3 (clonefs): same size as rootfs
	NEW_CLONEFS_START=$((NEW_ROOTFS_END + 1))
	NEW_CLONEFS_END=$((NEW_CLONEFS_START + ROOTFS_SIZE_SECTORS - 1))
	
	# Partition 4 (upperfs): from clonefs end to 16GiB limit or device end
	# For MBR extended partitions:
	# - Extended partition container starts before first logical partition
	# - First logical partition's EBR goes at the start of extended partition
	# - Logical partition data starts after EBR
	# So we need: gap after partition 3, then extended partition, then EBR, then partition data
	EXTENDED_START=$((NEW_CLONEFS_END + 1))
	# First logical partition EBR goes at EXTENDED_START, data starts at EXTENDED_START + 1
	NEW_UPPERFS_START=$((EXTENDED_START + 1))
	if [ "$LIMIT_16GIB_SECTORS" -lt "$DEVICE_END" ]; then
		# Reserve 1 sector for second EBR between upperfs and datafs
		NEW_UPPERFS_END=$((LIMIT_16GIB_SECTORS - 2))
		NEED_DATAFS=1
	else
		NEW_UPPERFS_END=$DEVICE_END
		NEED_DATAFS=0
	fi
	
	# Partition 5 (datafs): only if device > 16GiB
	# Second logical partition: EBR goes at NEW_UPPERFS_END + 1, data starts at NEW_UPPERFS_END + 2
	if [ "$NEED_DATAFS" -eq 1 ]; then
		NEW_DATAFS_START=$((NEW_UPPERFS_END + 2))  # +1 for EBR, +1 for next sector
		NEW_DATAFS_END=$DEVICE_END
		DATAFS_SIZE=$((NEW_DATAFS_END - NEW_DATAFS_START + 1))
		log_info_msg "Datafs will be created (device > 16GiB)"
	else
		log_info_msg "Datafs not needed (device <= 16GiB)"
	fi
	
	log_info_msg "New layout:"
	log_info_msg "  Partition 1 (bootfs):  $NEW_BOOTFS_START - $NEW_BOOTFS_END"
	log_info_msg "  Partition 2 (rootfs):  $NEW_ROOTFS_START - $NEW_ROOTFS_END"
	log_info_msg "  Partition 3 (clonefs): $NEW_CLONEFS_START - $NEW_CLONEFS_END"
	log_info_msg "  Partition 4 (upperfs): $NEW_UPPERFS_START - $NEW_UPPERFS_END"
	if [ "$NEED_DATAFS" -eq 1 ]; then
		log_info_msg "  Partition 5 (datafs):  $NEW_DATAFS_START - $NEW_DATAFS_END"
	fi
	
	log_end_msg
}

create_mbr_layout()
{
	log_begin_msg "Creating MBR partition layout with extended partitions"
	
	# Calculate extended partition boundaries
	# EXTENDED_START was already calculated in calculate_boundaries()
	# Extended partition ends at the last logical partition's end
	if [ "$NEED_DATAFS" -eq 1 ]; then
		EXTENDED_END=$NEW_DATAFS_END
	else
		EXTENDED_END=$NEW_UPPERFS_END
	fi
	
	EXTENDED_SIZE=$((EXTENDED_END - EXTENDED_START + 1))
	
	# Calculate partition sizes in sectors
	BOOTFS_SIZE=$((NEW_BOOTFS_END - NEW_BOOTFS_START + 1))
	ROOTFS_SIZE=$((NEW_ROOTFS_END - NEW_ROOTFS_START + 1))
	CLONEFS_SIZE=$((NEW_CLONEFS_END - NEW_CLONEFS_START + 1))
	UPPERFS_SIZE=$((NEW_UPPERFS_END - NEW_UPPERFS_START + 1))
	
	log_info_msg "Extended partition will span: $EXTENDED_START - $EXTENDED_END"
	
	# Build sfdisk input script
	# For MBR extended partitions:
	# - Extended partition (4) is a container
	# - Logical partitions (5, 6) are created within the extended partition
	# - sfdisk expects logical partition start to be where partition data starts
	# - sfdisk automatically places the EBR before the partition data
	# - So extended partition must start before the first logical partition's data start
	log_info_msg "Creating partition layout with sfdisk"
	
	# For logical partition 5: data starts at NEW_UPPERFS_START
	# sfdisk will automatically place EBR at EXTENDED_START (NEW_UPPERFS_START - 1)
	# Size is just the data size (EBR is handled by sfdisk)
	
	SFDISK_INPUT="label: dos
unit: sectors

${ROOT_DEV}1 : start=$NEW_BOOTFS_START, size=$BOOTFS_SIZE, type=c, bootable
${ROOT_DEV}2 : start=$NEW_ROOTFS_START, size=$ROOTFS_SIZE, type=83
${ROOT_DEV}3 : start=$NEW_CLONEFS_START, size=$CLONEFS_SIZE, type=83
${ROOT_DEV}4 : start=$EXTENDED_START, size=$EXTENDED_SIZE, type=5
${ROOT_DEV}5 : start=$NEW_UPPERFS_START, size=$UPPERFS_SIZE, type=83"
	
	# Add datafs partition if needed
	# For logical partition 6: data starts at NEW_DATAFS_START
	# sfdisk will automatically place EBR before it
	if [ "$NEED_DATAFS" -eq 1 ]; then
		log_info_msg "Adding datafs partition to layout"
		SFDISK_INPUT="$SFDISK_INPUT
${ROOT_DEV}6 : start=$NEW_DATAFS_START, size=$DATAFS_SIZE, type=c"
	fi
	
	# Apply partition layout
	log_info_msg "Applying partition layout"
	if ! echo "$SFDISK_INPUT" | sfdisk "$ROOT_DEV" 2>&1; then
		log_failure_msg "Failed to create MBR partition layout"
		return 1
	fi
	
	# Refresh partition table
	log_info_msg "Refreshing partition table"
	wait_for_udev 10
	blockdev --rereadpt "$ROOT_DEV" 2>/dev/null || partprobe "$ROOT_DEV" 2>/dev/null || true
	wait_for_udev 10
	
	# Verify partitions were created
	log_info_msg "Verifying partition creation"
	PART_COUNT=$(lsblk -n -o kname "$ROOT_DEV" | grep -E "^${ROOT_DEV_NAME}p?[0-9]+$" | wc -l)
	
	# Expected count: 5 partitions (1,2,3,4,5) or 6 partitions (1,2,3,4,5,6) if datafs needed
	# Note: partition 4 is the extended container, so it may or may not show up in lsblk
	if [ "$NEED_DATAFS" -eq 1 ]; then
		EXPECTED_MIN=5  # At minimum we need 1,2,3,5,6 (extended might not show)
		log_info_msg "Detected $PART_COUNT partitions after MBR creation (expected 5-6 with datafs)"
	else
		EXPECTED_MIN=4  # At minimum we need 1,2,3,5 (extended might not show)
		log_info_msg "Detected $PART_COUNT partitions after MBR creation (expected 4-5 without datafs)"
	fi
	
	if [ "$PART_COUNT" -lt "$EXPECTED_MIN" ]; then
		log_failure_msg "Partition creation verification failed: expected at least $EXPECTED_MIN, found $PART_COUNT"
		return 1
	fi
	
	log_end_msg
}

resize_rootfs()
{
	log_begin_msg "Resizing rootfs filesystem"
	
	# After repartitioning, the filesystem needs to be checked before resizing
	log_info_msg "Checking filesystem on $DEV"
	if ! e2fsck -fy "$DEV"; then
		log_failure_msg "Failed to check/repair rootfs filesystem"
		return 1
	fi
	
	# Resize ext4 filesystem to match new partition size
	log_info_msg "Running resize2fs on $DEV"
	if ! resize2fs -f -p "$DEV"; then
		log_failure_msg "Failed to resize rootfs filesystem"
		return 1
	fi
	
	log_info_msg "Rootfs filesystem resized successfully"
	log_end_msg
}

initialize_partitions()
{
	log_begin_msg "Initializing new partitions"
	
	# Build partition device names directly using partition numbers
	# Determine if device uses 'p' separator (e.g., mmcblk0p1 vs sda1)
	if echo "$ROOT_DEV_NAME" | grep -q '[0-9]$'; then
		# Device name ends in a number, needs 'p' separator
		PART_SEP="p"
	else
		# Device name doesn't end in a number, no separator needed
		PART_SEP=""
	fi
	
	# Partition 3 = clonefs
	CLONEFS_DEV="${ROOT_DEV}${PART_SEP}3"
	
	# Partition 5 = upperfs (logical partition in extended)
	UPPERFS_DEV="${ROOT_DEV}${PART_SEP}5"
	
	# Format clonefs (ext4) with filesystem label
	log_info_msg "Formatting clonefs partition: $CLONEFS_DEV"
	if ! mkfs.ext4 -F -L clonefs "$CLONEFS_DEV"; then
		log_failure_msg "Failed to format clonefs partition"
		return 1
	fi
	
	# Format upperfs (ext4) with filesystem label
	log_info_msg "Formatting upperfs partition: $UPPERFS_DEV"
	if ! mkfs.ext4 -F -L upperfs "$UPPERFS_DEV"; then
		log_failure_msg "Failed to format upperfs partition"
		return 1
	fi
	
	# Format datafs (ExFAT) with filesystem label if needed
	if [ "$NEED_DATAFS" -eq 1 ]; then
		# Partition 6 = datafs (logical partition in extended)
		DATAFS_DEV="${ROOT_DEV}${PART_SEP}6"
		
		log_info_msg "Formatting datafs partition: $DATAFS_DEV"
		if ! mkfs.exfat -n datafs "$DATAFS_DEV"; then
			log_failure_msg "Failed to format datafs partition"
			return 1
		fi
	fi
	
	log_end_msg
}

# Main execution flow
get_device_info

if ! check_mbr_and_read_layout; then
	exit 0
fi

# Detect watchdog and start petter if available
if detect_watchdog; then
	start_watchdog_petter
fi

calculate_boundaries
create_mbr_layout
resize_rootfs
initialize_partitions

# Stop watchdog petter before final success message
stop_watchdog_petter

log_success_msg "Repartition completed successfully"

exit 0
